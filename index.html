<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Curse of the Warlock</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  overflow: hidden; 
  background: #000; 
  font-family: 'Courier New', monospace;
  user-select: none; 
  touch-action: none;
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

#gameCanvas { 
  display: block;
  image-rendering: pixelated;
}

.hero-select {
  position: fixed;
  inset: 0;
  background: linear-gradient(135deg, #1a0f2e, #2d1b3d);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  overflow-y: auto;
}

.title {
  font-size: 56px;
  font-weight: bold;
  color: #ffd700;
  text-shadow: 4px 4px 0 #000, 0 0 20px #ff6b00;
  margin-bottom: 30px;
  letter-spacing: 3px;
  animation: glow 2s infinite;
}

@keyframes glow {
  0%, 100% { text-shadow: 4px 4px 0 #000, 0 0 20px #ff6b00; }
  50% { text-shadow: 4px 4px 0 #000, 0 0 40px #ff0000; }
}

.hero-grid {
  display: grid;
  grid-template-columns: repeat(3, 220px);
  gap: 25px;
  margin-bottom: 20px;
}

.hero-card {
  background: linear-gradient(135deg, #2a1a3a, #1f1030);
  border: 4px solid #4a3a5a;
  border-radius: 8px;
  padding: 20px;
  cursor: pointer;
  transition: all 0.3s;
  text-align: center;
  position: relative;
}

.hero-card:hover {
  transform: translateY(-8px) scale(1.05);
  border-color: #ffd700;
  box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
}

.hero-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(180deg, transparent, rgba(0,0,0,0.5));
  border-radius: 4px;
}

.hero-icon {
  font-size: 70px;
  margin-bottom: 12px;
  filter: drop-shadow(0 0 10px currentColor);
  position: relative;
  z-index: 1;
}

.hero-name {
  font-size: 18px;
  font-weight: bold;
  color: #ffd700;
  margin-bottom: 8px;
  text-shadow: 2px 2px 0 #000;
  position: relative;
  z-index: 1;
}

.hero-role {
  font-size: 12px;
  color: #aaa;
  margin-bottom: 5px;
  position: relative;
  z-index: 1;
}

.hero-stats {
  font-size: 11px;
  color: #88ff88;
  line-height: 1.6;
  text-align: left;
  margin-top: 8px;
  position: relative;
  z-index: 1;
}

.ui-overlay {
  position: fixed;
  pointer-events: none;
  z-index: 100;
}

.top-hud {
  top: 10px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  padding: 0 15px;
  gap: 15px;
}

.hero-info, .score-board {
  background: linear-gradient(135deg, rgba(10, 5, 20, 0.95), rgba(30, 15, 40, 0.95));
  padding: 12px 18px;
  border-radius: 6px;
  border: 3px solid #4a3060;
  color: white;
  box-shadow: 0 4px 15px rgba(0,0,0,0.7);
}

.hero-name-text {
  font-size: 18px;
  font-weight: bold;
  color: #ffd700;
  margin-bottom: 8px;
  text-shadow: 2px 2px 0 #000;
}

.stat-row {
  display: flex;
  gap: 12px;
  font-size: 13px;
}

.bar {
  width: 100px;
  height: 10px;
  background: #222;
  border: 2px solid #444;
  border-radius: 2px;
  overflow: hidden;
  margin-top: 3px;
  box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
}

.bar-fill {
  height: 100%;
  transition: width 0.3s;
  box-shadow: 0 0 10px currentColor;
}

.hp-bar { background: linear-gradient(90deg, #cc0000, #ff3333); }
.mp-bar { background: linear-gradient(90deg, #0044cc, #4488ff); }

.bottom-ui {
  bottom: 15px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  padding: 0 15px;
}

.joystick-area {
  width: 140px;
  height: 140px;
  position: relative;
  pointer-events: all;
}

.joystick-base {
  width: 110px;
  height: 110px;
  background: radial-gradient(circle, rgba(60,40,80,0.4), rgba(30,20,40,0.8));
  border: 3px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  position: absolute;
  top: 15px;
  left: 15px;
  box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
}

.joystick-stick {
  width: 45px;
  height: 45px;
  background: radial-gradient(circle, #fff, #ccc);
  border: 3px solid #ffd700;
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: all 0.05s;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}

.abilities {
  display: flex;
  gap: 10px;
  pointer-events: all;
}

.ability-btn {
  width: 65px;
  height: 65px;
  background: linear-gradient(135deg, rgba(20,10,40,0.95), rgba(40,20,60,0.95));
  border: 3px solid #6644aa;
  border-radius: 6px;
  color: #fff;
  font-size: 22px;
  cursor: pointer;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  text-shadow: 2px 2px 0 #000;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}

.ability-btn:active {
  transform: scale(0.92);
}

.ability-btn.ult {
  border-color: #ff00ff;
  box-shadow: 0 0 20px rgba(255,0,255,0.6), 0 4px 10px rgba(0,0,0,0.5);
}

.ability-btn.cd {
  opacity: 0.3;
  cursor: not-allowed;
}

.cd-text {
  position: absolute;
  font-size: 18px;
  color: #fff;
}

.minimap {
  width: 160px;
  height: 160px;
  background: rgba(0,0,0,0.9);
  border: 3px solid #4a3060;
  border-radius: 6px;
  pointer-events: all;
  box-shadow: 0 4px 15px rgba(0,0,0,0.7);
}

.gold {
  position: fixed;
  bottom: 200px;
  right: 25px;
  background: linear-gradient(135deg, rgba(10,5,20,0.95), rgba(30,15,40,0.95));
  padding: 10px 20px;
  border-radius: 6px;
  border: 3px solid #ffd700;
  color: #ffd700;
  font-size: 20px;
  font-weight: bold;
  z-index: 100;
  text-shadow: 2px 2px 0 #000;
  box-shadow: 0 4px 15px rgba(0,0,0,0.7);
}

.notification {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.95);
  padding: 12px 30px;
  border-radius: 6px;
  border: 3px solid #ffd700;
  color: #ffd700;
  font-size: 16px;
  font-weight: bold;
  z-index: 9999;
  animation: slideIn 0.5s;
  text-shadow: 2px 2px 0 #000;
}

@keyframes slideIn {
  from { top: 60px; opacity: 0; }
  to { top: 100px; opacity: 1; }
}

.damage-text {
  position: fixed;
  font-size: 20px;
  font-weight: bold;
  color: #ff3333;
  text-shadow: 2px 2px 0 #000, 0 0 10px #ff0000;
  animation: floatUp 1s forwards;
  z-index: 9998;
  pointer-events: none;
}

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(0.8); }
  50% { transform: translateY(-35px) scale(1.2); }
  100% { opacity: 0; transform: translateY(-70px); }
}

.curse-meter {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  width: 300px;
  background: rgba(0,0,0,0.9);
  padding: 10px;
  border: 3px solid #8844ff;
  border-radius: 6px;
  display: none;
}

.curse-bar-container {
  height: 15px;
  background: #222;
  border: 2px solid #444;
  border-radius: 3px;
  overflow: hidden;
  margin-top: 5px;
}

.curse-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #8844ff, #ff00ff);
  width: 0%;
  transition: width 0.5s;
  box-shadow: 0 0 15px #ff00ff;
}

.talent-popup {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.9);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10000;
}

.talent-container {
  background: linear-gradient(135deg, #2a1a3a, #1f1030);
  border: 4px solid #ffd700;
  border-radius: 8px;
  padding: 30px;
  max-width: 600px;
}

.talent-title {
  font-size: 28px;
  color: #ffd700;
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 2px 2px 0 #000;
}

.talent-options {
  display: flex;
  gap: 20px;
  justify-content: center;
}

.talent-option {
  background: rgba(50,30,70,0.8);
  border: 3px solid #6644aa;
  border-radius: 6px;
  padding: 20px;
  cursor: pointer;
  transition: all 0.3s;
  text-align: center;
  min-width: 200px;
}

.talent-option:hover {
  border-color: #ffd700;
  transform: scale(1.05);
  box-shadow: 0 0 20px rgba(255,215,0,0.5);
}

.shop-panel {
  position: fixed;
  right: 20px;
  top: 100px;
  width: 280px;
  background: linear-gradient(135deg, rgba(10,5,20,0.98), rgba(30,15,40,0.98));
  border: 3px solid #4a3060;
  border-radius: 6px;
  padding: 15px;
  display: none;
  max-height: 500px;
  overflow-y: auto;
  z-index: 200;
}

.shop-title {
  font-size: 18px;
  color: #ffd700;
  margin-bottom: 15px;
  text-align: center;
  text-shadow: 2px 2px 0 #000;
}

.shop-item {
  background: rgba(40,20,60,0.6);
  border: 2px solid #6644aa;
  border-radius: 4px;
  padding: 10px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.2s;
}

.shop-item:hover {
  border-color: #ffd700;
  transform: translateX(5px);
}

.item-name {
  color: #ffd700;
  font-weight: bold;
  font-size: 14px;
}

.item-cost {
  color: #ffaa00;
  font-size: 12px;
  margin-top: 3px;
}

.item-desc {
  color: #aaa;
  font-size: 11px;
  margin-top: 5px;
}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div class="hero-select" id="heroSelect">
  <div class="title">‚öîÔ∏è CURSE OF THE WARLOCK ‚öîÔ∏è</div>
  <div class="hero-grid" id="heroGrid"></div>
</div>

<div class="ui-overlay top-hud" id="topHud" style="display:none;">
  <div class="hero-info">
    <div class="hero-name-text" id="heroName">–ì–µ—Ä–æ–π</div>
    <div class="stat-row">
      <div>
        <div>HP: <span id="hpText">0/0</span></div>
        <div class="bar"><div class="bar-fill hp-bar" id="hpBar" style="width:100%"></div></div>
      </div>
      <div>
        <div>MP: <span id="mpText">0/0</span></div>
        <div class="bar"><div class="bar-fill mp-bar" id="mpBar" style="width:100%"></div></div>
      </div>
      <div>
        <div>–£—Ä. <span id="level">1</span></div>
        <div>–û–ø—ã—Ç: <span id="exp">0</span></div>
      </div>
    </div>
  </div>
  <div class="score-board">
    <div style="display:flex;gap:25px;font-size:20px;">
      <span style="color:#90ee90">‚öîÔ∏è <span id="radiantScore">0</span></span>
      <span style="color:#ff6666"><span id="direScore">0</span> ‚öîÔ∏è</span>
    </div>
    <div style="text-align:center;margin-top:5px;font-size:14px;">‚è±Ô∏è <span id="gameTime">0:00</span></div>
  </div>
</div>

<div class="curse-meter" id="curseMeter">
  <div style="color:#ff00ff;text-align:center;font-size:14px;font-weight:bold;text-shadow:2px 2px 0 #000;">
    –ü–†–û–ö–õ–Ø–¢–ò–ï –í–ê–†–õ–û–ö–ê
  </div>
  <div class="curse-bar-container">
    <div class="curse-bar-fill" id="curseBar"></div>
  </div>
</div>

<div class="ui-overlay bottom-ui" id="bottomUi" style="display:none;">
  <div class="joystick-area" id="joystickArea">
    <div class="joystick-base"></div>
    <div class="joystick-stick" id="joystick"></div>
  </div>
  <div class="abilities" id="abilities"></div>
  <canvas class="minimap" id="minimap" width="160" height="160"></canvas>
</div>

<div class="gold" id="gold" style="display:none;">üí∞ <span id="goldAmount">625</span></div>

<div class="shop-panel" id="shopPanel">
  <div class="shop-title">üè™ –ú–ê–ì–ê–ó–ò–ù –†–ï–õ–ò–ö–í–ò–ô</div>
  <div id="shopItems"></div>
</div>

<div class="talent-popup" id="talentPopup">
  <div class="talent-container">
    <div class="talent-title">‚ú® –í–´–ë–ï–†–ò–¢–ï –¢–ê–õ–ê–ù–¢ ‚ú®</div>
    <div class="talent-options" id="talentOptions"></div>
  </div>
</div>

<script>
const CONFIG = {
  MAP_SIZE: 6000,
  CREEP_SPAWN: 30000,
  TOWER_RANGE: 400,
  EXP_TO_LEVEL: [0, 200, 450, 750, 1100, 1500, 1950, 2450, 3000, 3600, 4250, 4950, 5700, 6500, 7350, 8250, 9200, 10200, 11250, 12350],
  PIXEL_SIZE: 2,
  CURSE_THRESHOLD: 100,
  NIGHT_DURATION: 120000
};

const HEROES = {
  korbin: {
    name: "–ö–æ—Ä–±–∏–Ω –ü–ª–æ–¥–æ—Ä–æ–¥–Ω—ã–π",
    emoji: "üçç",
    role: "–¢–∞–Ω–∫ / –ü–æ–¥–¥–µ—Ä–∂–∫–∞",
    color: "#FFD700",
    hp: 850,
    mp: 420,
    dmg: 48,
    armor: 8,
    magicRes: 25,
    speed: 3.0,
    staffColor: "#8B4513",
    gemColor: "#FFD700",
    abilities: {
      q: { name: "–õ–∏–ø–∫–∏–π –°–æ–∫", damage: 80, cd: 4000, manaCost: 60, desc: "–ó–∞–º–µ–¥–ª—è–µ—Ç –≤—Ä–∞–≥–æ–≤ –Ω–∞ 40%" },
      w: { name: "–¢—Ä–æ–ø–∏—á–µ—Å–∫–∏–π –©–∏—Ç", cd: 10000, manaCost: 80, desc: "–©–∏—Ç –Ω–∞ 200 HP —Å–æ—é–∑–Ω–∏–∫—É" },
      r: { name: "–í–∏—Ç–∞–º–∏–Ω–Ω—ã–π –ë—É–º", damage: 250, cd: 90000, manaCost: 150, desc: "–ê–æ–ï —É—Ä–æ–Ω + –ª–µ—á–µ–Ω–∏–µ —Å–æ—é–∑–Ω–∏–∫–æ–≤" }
    },
    passive: "–°–ª–∞–¥–∫–∞—è –ö–æ—Ä–∫–∞: –ó–∞ –∫–∞–∂–¥—ã–µ 500 —É—Ä–æ–Ω–∞ —Ä–æ–Ω—è–µ—Ç —Ñ—Ä—É–∫—Ç (+5% HP)"
  },
  lyra: {
    name: "–õ–∏—Ä–∞ –õ—É–Ω–Ω–∞—è",
    emoji: "üåô",
    role: "–ú–∞–≥ –ö–æ–Ω—Ç—Ä–æ–ª—è",
    color: "#87CEEB",
    hp: 550,
    mp: 650,
    dmg: 62,
    armor: 3,
    magicRes: 30,
    speed: 3.4,
    staffColor: "#4169E1",
    gemColor: "#87CEEB",
    abilities: {
      q: { name: "–°–≤–µ—Ç –õ—É–Ω—ã", damage: 120, cd: 6000, manaCost: 70, desc: "–õ—É—á, –æ—Å–ª–µ–ø–ª—è—é—â–∏–π –≤—Ä–∞–≥–æ–≤" },
      w: { name: "–ü—Ä–∏–ª–∏–≤", damage: 90, cd: 12000, manaCost: 90, desc: "–û—Ç—Ç–∞–ª–∫–∏–≤–∞–µ—Ç –≤—Ä–∞–≥–æ–≤" },
      r: { name: "–ó–∞—Ç–º–µ–Ω–∏–µ", cd: 100000, manaCost: 200, desc: "–ù–∞–∫—Ä—ã–≤–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å —Ç—å–º–æ–π –Ω–∞ 4 —Å–µ–∫" }
    },
    passive: "–õ—É–Ω–Ω—ã–π –¶–∏–∫–ª: –ö–∞–∂–¥—ã–µ 15—Å —Å–ª–µ–¥—É—é—â–∞—è –∞—Ç–∞–∫–∞ –∑–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ—Ç"
  },
  grolak: {
    name: "–ì—Ä–æ–ª–∞–∫ –ì–Ω–∏–ª–æ–π",
    emoji: "‚ò†Ô∏è",
    role: "–ú–∞–≥ –û—Ç—Ä–∞–≤–∏—Ç–µ–ª—å",
    color: "#32CD32",
    hp: 620,
    mp: 580,
    dmg: 56,
    armor: 4,
    magicRes: 28,
    speed: 2.9,
    staffColor: "#228B22",
    gemColor: "#7FFF00",
    abilities: {
      q: { name: "–Ø–¥–æ–≤–∏—Ç–æ–µ –û–±–ª–∞–∫–æ", damage: 45, cd: 5000, manaCost: 65, desc: "DoT —è–¥ 5 —Å–µ–∫" },
      w: { name: "–ï–¥–∫–∏–π –°–æ—Å—Ç–∞–≤", cd: 11000, manaCost: 75, desc: "–°–Ω–∏–∂–∞–µ—Ç –∑–∞—â–∏—Ç—É –Ω–∞ 30%" },
      r: { name: "–ë–æ–ª–æ—Ç–Ω–∞—è –¢—Ä—è—Å–∏–Ω–∞", damage: 180, cd: 95000, manaCost: 180, desc: "–û–≥—Ä–æ–º–Ω–∞—è –æ–±–ª–∞—Å—Ç—å —è–¥–∞" }
    },
    passive: "–¢–æ–∫—Å–∏—á–Ω—ã–π –°–ª–µ–¥: –û—Å—Ç–∞–≤–ª—è–µ—Ç —è–¥ –ø—Ä–∏ —Ö–æ–¥—å–±–µ"
  },
  elara: {
    name: "–≠–ª–∞—Ä–∞ –¢—Ä–∞–≤–Ω–∏—Ü–∞",
    emoji: "üåø",
    role: "–ü—Ä–∏–∑—ã–≤–∞—Ç–µ–ª—å / –õ–µ–∫–∞—Ä—å",
    color: "#228B22",
    hp: 680,
    mp: 600,
    dmg: 52,
    armor: 5,
    magicRes: 27,
    speed: 3.2,
    staffColor: "#8B4513",
    gemColor: "#00FF00",
    abilities: {
      q: { name: "–ñ–∏–≤—ã–µ –õ–æ–∑—ã", damage: 70, cd: 7000, manaCost: 70, desc: "–ö–æ—Ä–Ω–∏ –ø—Ä–∏–∫–æ–≤—ã–≤–∞—é—Ç –≤—Ä–∞–≥–∞" },
      w: { name: "–ó–µ–ª—å–µ –°–∏–ª—ã", cd: 9000, manaCost: 60, desc: "+15% —É—Ä–æ–Ω–∞ —Å–æ—é–∑–Ω–∏–∫—É" },
      r: { name: "–î—É—Ö –õ–µ—Å–∞", cd: 110000, manaCost: 160, desc: "–ü—Ä–∏–∑—ã–≤–∞–µ—Ç –¥—Ä–µ–≤–Ω—è –Ω–∞ 20 —Å–µ–∫" }
    },
    passive: "–°–∏–Ω–µ—Ä–≥–∏—è –¢—Ä–∞–≤: –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –ª–µ—á–∞—Ç –Ω–∞ 3% HP"
  },
  xolar: {
    name: "–ösol'ar –ë—ã—Å—Ç—Ä—ã–π",
    emoji: "ü¶Ö",
    role: "–ê—Å—Å–∞—Å–∏–Ω",
    color: "#FF6347",
    hp: 590,
    mp: 460,
    dmg: 78,
    armor: 2,
    magicRes: 22,
    speed: 4.2,
    staffColor: "#CD5C5C",
    gemColor: "#FF69B4",
    abilities: {
      q: { name: "–ü–æ–ª–µ—Ç –°–æ–∫–æ–ª–∞", damage: 140, cd: 8000, manaCost: 80, desc: "–†—ã–≤–æ–∫ + –ø–æ–¥–±—Ä–æ—Å –≤—Ä–∞–≥–∞" },
      w: { name: "–ü–µ—Ä—å–µ–≤–æ–π –®–∫–≤–∞–ª", damage: 160, cd: 10000, manaCost: 95, desc: "8 –ø–µ—Ä—å–µ–≤ –ø–æ –∫—Ä—É–≥—É" },
      r: { name: "–í–∑–æ—Ä –¢–æ—Ç–µ–º–∞", cd: 85000, manaCost: 120, desc: "–¢–æ—Ç–µ–º + —Ç–µ–ª–µ–ø–æ—Ä—Ç" }
    },
    passive: "–õ–µ–≥–∫–æ–µ –ü–µ—Ä–æ: –ü–æ—Å–ª–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ —Å–ª–µ–¥—É—é—â–∏–π —É–¥–∞—Ä - –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π"
  },
  ignis: {
    name: "–ò–≥–Ω–∏—Å –ü–ª–∞–º–µ–Ω–Ω—ã–π",
    emoji: "üî•",
    role: "–ú–∞–≥ –î–î",
    color: "#FF4500",
    hp: 520,
    mp: 700,
    dmg: 68,
    armor: 2,
    magicRes: 26,
    speed: 3.3,
    staffColor: "#8B0000",
    gemColor: "#FF4500",
    abilities: {
      q: { name: "–û–≥–Ω–µ–Ω–Ω—ã–π –®–∞—Ä", damage: 130, cd: 3500, manaCost: 55, desc: "–ë—ã—Å—Ç—Ä—ã–π —Å–Ω–∞—Ä—è–¥" },
      w: { name: "–°—Ç–µ–Ω–∞ –û–≥–Ω—è", damage: 100, cd: 13000, manaCost: 100, desc: "–ü—Ä–µ–≥—Ä–∞–¥–∞ –∏–∑ –ø–ª–∞–º–µ–Ω–∏" },
      r: { name: "–ì–Ω–µ–≤ –í—É–ª–∫–∞–Ω–∞", damage: 320, cd: 105000, manaCost: 220, desc: "–í–∑—Ä—ã–≤ + —Ñ–æ—Ä–º–∞ —ç–ª–µ–º–µ–Ω—Ç–∞–ª—è" }
    },
    passive: "–ü–µ—Ä–µ–≥—Ä–µ–≤: –ö–∞–∂–¥–æ–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ +5% —É—Ä–æ–Ω–∞ (–¥–æ 100%)"
  }
};

const ITEMS = [
  { id: 1, name: "–û—Å–∫–æ–ª–æ–∫ –ü—É—Å—Ç–æ—Ç—ã", cost: 850, bonus: "+35 —É—Ä–æ–Ω–∞", effect: "–ö–∞–∂–¥–∞—è 3-—è –∞—Ç–∞–∫–∞ - —á–∏—Å—Ç—ã–π —É—Ä–æ–Ω" },
  { id: 2, name: "–ü–ª–∞—â –°–º–∏—Ä–µ–Ω–∏—è", cost: 1200, bonus: "+150 HP", effect: "–ü—Ä–∏ —Å—Ç–∞–Ω–µ –¥–∞–µ—Ç —â–∏—Ç 10% HP" },
  { id: 3, name: "–ì–ª–∞–∑ –ò—Å–∫—É—Å–∏—Ç–µ–ª—è", cost: 1600, bonus: "+45 –º–∞–≥–∏—è", effect: "–ê–æ–ï –ø–æ–¥–∂–∏–≥–∞–µ—Ç –∑–µ–º–ª—é" },
  { id: 4, name: "–°–∞–ø–æ–≥–∏ –≠—Ñ–∏—Ä–∞", cost: 700, bonus: "+70 —Å–∫–æ—Ä–æ—Å—Ç—å", effect: "–ü—Ä–æ—Ö–æ–¥–∏—Ç–µ —Å–∫–≤–æ–∑—å —é–Ω–∏—Ç–æ–≤" },
  { id: 5, name: "–ö—Ä–∏—Å—Ç–∞–ª–ª –î—É—à–∏", cost: 2100, bonus: "+200 –º–∞–Ω–∞", effect: "+15% –≤–æ—Å—Å—Ç. –º–∞–Ω—ã" },
  { id: 6, name: "–ú–æ–ª–æ—Ç –¢–∏—Ç–∞–Ω–æ–≤", cost: 1850, bonus: "+60 —É—Ä–æ–Ω, +8 –±—Ä–æ–Ω—è", effect: "–ê—Ç–∞–∫–∏ –∑–∞–º–µ–¥–ª—è—é—Ç –Ω–∞ 20%" },
  { id: 7, name: "–ö–Ω–∏–≥–∞ –ú–µ—Ä—Ç–≤—ã—Ö", cost: 2400, bonus: "+80 –º–∞–≥–∏—è, +300 HP", effect: "–í–∞–º–ø–∏—Ä–∏–∑–º –ø–æ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è–º 15%" },
  { id: 8, name: "–®–∏–ø–æ–≤–∞–Ω–Ω—ã–π –ü–∞–Ω—Ü–∏—Ä—å", cost: 1500, bonus: "+12 –±—Ä–æ–Ω—è", effect: "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç 20% —É—Ä–æ–Ω–∞" },
  { id: 9, name: "–ê–º—É–ª–µ—Ç –ü—Ä–æ–∫–ª—è—Ç—å—è", cost: 3200, bonus: "+100 –º–∞–≥–∏—è", effect: "–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ —Å–Ω–∏–∂–∞—é—Ç —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ" },
  { id: 10, name: "–ö–æ–≥—Ç–∏ –•–∏—â–Ω–∏–∫–∞", cost: 1900, bonus: "+50 —É—Ä–æ–Ω, +25% –∫—Ä–∏—Ç", effect: "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —É–¥–∞—Ä—ã –ª–µ—á–∞—Ç" }
];

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = 'select';
let player = null;
let camera = { x: 0, y: 0 };
let structures = [];
let creeps = [];
let projectiles = [];
let particles = [];
let items = [];
let effects = [];

let joystickX = 0, joystickY = 0;
let gameTime = 0;
let lastCreepSpawn = 0;
let radiantKills = 0, direKills = 0;
let keys = {};
let curseProgress = 0;
let isNightOfWarlock = false;
let nightEndTime = 0;
let neutralMonsters = [];

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Populate hero selection
const heroGrid = document.getElementById('heroGrid');
Object.entries(HEROES).forEach(([key, hero]) => {
  const card = document.createElement('div');
  card.className = 'hero-card';
  card.style.borderColor = hero.color;
  card.innerHTML = `
    <div class="hero-icon" style="color:${hero.color}">${hero.emoji}</div>
    <div class="hero-name">${hero.name}</div>
    <div class="hero-role">${hero.role}</div>
    <div class="hero-stats">
      HP: ${hero.hp} | MP: ${hero.mp}<br>
      –£—Ä–æ–Ω: ${hero.dmg} | –°–∫–æ—Ä–æ—Å—Ç—å: ${hero.speed}<br>
      –ë—Ä–æ–Ω—è: ${hero.armor} | –ú–∞–≥.–∑–∞—â–∏—Ç–∞: ${hero.magicRes}
    </div>
  `;
  card.onclick = () => selectHero(key);
  heroGrid.appendChild(card);
});

// Populate shop
const shopItems = document.getElementById('shopItems');
ITEMS.forEach(item => {
  const itemEl = document.createElement('div');
  itemEl.className = 'shop-item';
  itemEl.innerHTML = `
    <div class="item-name">${item.name}</div>
    <div class="item-cost">üí∞ ${item.cost}</div>
    <div class="item-desc">${item.bonus}<br>${item.effect}</div>
  `;
  itemEl.onclick = () => buyItem(item);
  shopItems.appendChild(itemEl);
});

function selectHero(key) {
  const hero = HEROES[key];
  player = {
    x: 1200,
    y: 5000,
    vx: 0,
    vy: 0,
    speed: hero.speed,
    radius: 16,
    hp: hero.hp,
    maxHp: hero.hp,
    mp: hero.mp,
    maxMp: hero.mp,
    gold: 625,
    level: 1,
    exp: 0,
    color: hero.color,
    heroKey: key,
    damage: hero.dmg,
    armor: hero.armor,
    magicRes: hero.magicRes,
    alive: true,
    staffAngle: 0,
    inventory: [],
    kills: 0,
    deaths: 0,
    talents: { t10: null, t15: null, t20: null, t25: null }
  };

  document.getElementById('heroSelect').style.display = 'none';
  document.getElementById('topHud').style.display = 'flex';
  document.getElementById('bottomUi').style.display = 'flex';
  document.getElementById('gold').style.display = 'block';
  document.getElementById('curseMeter').style.display = 'block';
  document.getElementById('heroName').textContent = hero.name;

  initAbilities();
  initGame();
  gameState = 'playing';
  lastTime = performance.now();
  gameLoop(performance.now());
}

function initAbilities() {
  const panel = document.getElementById('abilities');
  panel.innerHTML = '';
  const hero = HEROES[player.heroKey];
  
  ['Q', 'W', 'R'].forEach((key, i) => {
    const ability = hero.abilities[key.toLowerCase()];
    const btn = document.createElement('div');
    btn.className = 'ability-btn' + (i === 2 ? ' ult' : '');
    btn.id = 'ability' + key;
    btn.textContent = key;
    btn.title = `${ability.name} (${ability.manaCost} –º–∞–Ω—ã)`;
    btn.onclick = () => useAbility(key.toLowerCase());
    panel.appendChild(btn);
  });
}

function initGame() {
  // Create tower structures - 3 lanes with 3 towers each
  const lanes = [
    // Top lane
    { 
      radiant: [[900, 5100], [1800, 4200], [2700, 3300]], 
      dire: [[5100, 900], [4200, 1800], [3300, 2700]] 
    },
    // Mid lane
    { 
      radiant: [[900, 900], [2100, 2100], [3300, 3300]], 
      dire: [[5100, 5100], [3900, 3900], [2700, 2700]] 
    },
    // Bot lane
    { 
      radiant: [[5100, 900], [4200, 1800], [3300, 2700]], 
      dire: [[900, 5100], [1800, 4200], [2700, 3300]] 
    }
  ];

  lanes.forEach((lane, laneIdx) => {
    ['radiant', 'dire'].forEach(team => {
      lane[team].forEach(([x, y], towerIdx) => {
        structures.push({
          type: 'tower',
          team,
          x,
          y,
          hp: 2800,
          maxHp: 2800,
          radius: 24,
          range: CONFIG.TOWER_RANGE,
          damage: 200,
          alive: true,
          lastAttack: 0,
          attackSpeed: 1000,
          lane: laneIdx,
          tier: towerIdx + 1
        });
      });
    });
  });

  // Add ancient bases
  structures.push({
    type: 'ancient',
    team: 'radiant',
    x: 600,
    y: 5400,
    hp: 5000,
    maxHp: 5000,
    radius: 40,
    range: 500,
    damage: 250,
    alive: true,
    lastAttack: 0,
    attackSpeed: 800
  });

  structures.push({
    type: 'ancient',
    team: 'dire',
    x: 5400,
    y: 600,
    hp: 5000,
    maxHp: 5000,
    radius: 40,
    range: 500,
    damage: 250,
    alive: true,
    lastAttack: 0,
    attackSpeed: 800
  });

  spawnCreeps();
  createParticles();
  spawnNeutralMonsters();
}

function spawnCreeps() {
  const spawns = [
    { radiant: [600, 5000], dire: [5000, 600] },     // Top
    { radiant: [600, 600], dire: [5400, 5400] },     // Mid
    { radiant: [5000, 600], dire: [600, 5000] }      // Bot
  ];

  spawns.forEach((spawn, laneIdx) => {
    ['radiant', 'dire'].forEach(team => {
      const [x, y] = spawn[team];
      
      // Melee creeps
      for (let i = 0; i < 3; i++) {
        creeps.push({
          x: x + (Math.random() - 0.5) * 120,
          y: y + (Math.random() - 0.5) * 120,
          team,
          type: 'melee',
          hp: 550,
          maxHp: 550,
          radius: 10,
          speed: 2.2,
          damage: 28,
          gold: 45,
          exp: 62,
          alive: true,
          target: null,
          lastAttack: 0,
          attackSpeed: 1200,
          lane: laneIdx
        });
      }
      
      // Ranged creep
      creeps.push({
        x: x + (Math.random() - 0.5) * 120,
        y: y + (Math.random() - 0.5) * 120,
        team,
        type: 'ranged',
        hp: 300,
        maxHp: 300,
        radius: 8,
        speed: 2.5,
        damage: 22,
        gold: 50,
        exp: 41,
        alive: true,
        target: null,
        lastAttack: 0,
        attackSpeed: 1500,
        attackRange: 450,
        lane: laneIdx
      });
    });
  });
}

function spawnNeutralMonsters() {
  // Jungle camps
  const camps = [
    { x: 1500, y: 1500, type: 'small' },
    { x: 4500, y: 4500, type: 'small' },
    { x: 1500, y: 4500, type: 'medium' },
    { x: 4500, y: 1500, type: 'medium' },
    { x: 3000, y: 3000, type: 'boss' }
  ];

  camps.forEach(camp => {
    const count = camp.type === 'boss' ? 1 : camp.type === 'medium' ? 3 : 2;
    const hp = camp.type === 'boss' ? 8000 : camp.type === 'medium' ? 1200 : 600;
    const damage = camp.type === 'boss' ? 180 : camp.type === 'medium' ? 80 : 45;
    const gold = camp.type === 'boss' ? 300 : camp.type === 'medium' ? 100 : 50;
    
    for (let i = 0; i < count; i++) {
      neutralMonsters.push({
        x: camp.x + (Math.random() - 0.5) * 100,
        y: camp.y + (Math.random() - 0.5) * 100,
        type: camp.type,
        hp: hp,
        maxHp: hp,
        radius: camp.type === 'boss' ? 30 : 12,
        speed: camp.type === 'boss' ? 2.8 : 1.5,
        damage: damage,
        gold: gold,
        exp: gold * 2,
        alive: true,
        aggressive: false,
        target: null,
        lastAttack: 0,
        attackSpeed: 1500,
        homeX: camp.x,
        homeY: camp.y,
        leashRange: 800
      });
    }
  });
}

function createParticles() {
  for (let i = 0; i < 150; i++) {
    particles.push({
      x: Math.random() * CONFIG.MAP_SIZE,
      y: Math.random() * CONFIG.MAP_SIZE,
      vx: (Math.random() - 0.5) * 0.6,
      vy: (Math.random() - 0.5) * 0.6,
      size: Math.random() * 2 + 1,
      alpha: Math.random() * 0.4 + 0.1,
      color: ['#6699ff', '#8844ff', '#ff00ff'][Math.floor(Math.random() * 3)]
    });
  }
}

// Input handlers
const joystickArea = document.getElementById('joystickArea');
const joystick = document.getElementById('joystick');

function handleJoystick(e) {
  e.preventDefault();
  const touch = e.touches ? e.touches[0] : e;
  const rect = joystickArea.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  
  let dx = touch.clientX - cx;
  let dy = touch.clientY - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const max = 40;
  
  if (dist > max) {
    dx = (dx / dist) * max;
    dy = (dy / dist) * max;
  }
  
  joystickX = dx / max;
  joystickY = dy / max;
  joystick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}

function resetJoystick() {
  joystickX = 0;
  joystickY = 0;
  joystick.style.transform = 'translate(-50%, -50%)';
}

joystickArea.addEventListener('touchstart', handleJoystick);
joystickArea.addEventListener('touchmove', handleJoystick);
joystickArea.addEventListener('touchend', resetJoystick);
joystickArea.addEventListener('mousedown', handleJoystick);

let isMouseDown = false;
document.addEventListener('mousemove', (e) => {
  if (isMouseDown && joystickArea.contains(e.target)) {
    handleJoystick(e);
  }
});
document.addEventListener('mousedown', (e) => {
  if (joystickArea.contains(e.target)) {
    isMouseDown = true;
    handleJoystick(e);
  }
});
document.addEventListener('mouseup', () => {
  isMouseDown = false;
  resetJoystick();
});

// Keyboard
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key.toLowerCase() === 'q') useAbility('q');
  if (e.key.toLowerCase() === 'w') useAbility('w');
  if (e.key.toLowerCase() === 'r') useAbility('r');
  if (e.key.toLowerCase() === 'b') toggleShop();
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// Abilities system
let abilities = { q: { cd: 0 }, w: { cd: 0 }, r: { cd: 0 } };

function useAbility(key) {
  if (!player || !player.alive || gameState !== 'playing') return;
  
  const hero = HEROES[player.heroKey];
  const ability = hero.abilities[key];
  const abilityState = abilities[key];
  
  if (abilityState.cd > 0 || player.mp < ability.manaCost) return;

  player.mp -= ability.manaCost;
  abilityState.cd = ability.cd;

  const angle = player.staffAngle || 0;
  
  // Create projectile
  const projectile = {
    x: player.x + Math.cos(angle) * 30,
    y: player.y + Math.sin(angle) * 30,
    vx: Math.cos(angle) * (key === 'r' ? 12 : 10),
    vy: Math.sin(angle) * (key === 'r' ? 12 : 10),
    damage: ability.damage || 100,
    radius: key === 'r' ? 24 : 14,
    color: player.color,
    team: 'radiant',
    dist: 0,
    maxDist: key === 'r' ? 1000 : 700,
    abilityType: key,
    owner: player
  };
  
  projectiles.push(projectile);
  
  // Visual effect
  createEffect(player.x, player.y, player.color, 'cast');
  
  showNotification(`${ability.name}!`);
}

function createEffect(x, y, color, type) {
  effects.push({
    x, y, color, type,
    life: 0,
    maxLife: type === 'cast' ? 30 : 20,
    radius: type === 'cast' ? 40 : 30
  });
}

function buyItem(item) {
  if (!player) return;
  
  if (player.gold >= item.cost) {
    if (player.inventory.length >= 6) {
      showNotification('–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø–æ–ª–æ–Ω!');
      return;
    }
    
    player.gold -= item.cost;
    player.inventory.push(item);
    
    // Apply item bonuses
    applyItemBonus(item);
    
    showNotification(`–ö—É–ø–ª–µ–Ω–æ: ${item.name}`);
  } else {
    showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–æ–ª–æ—Ç–∞!');
  }
}

function applyItemBonus(item) {
  // Parse and apply bonuses
  if (item.bonus.includes('—É—Ä–æ–Ω')) {
    const match = item.bonus.match(/\+(\d+)\s*—É—Ä–æ–Ω/);
    if (match) player.damage += parseInt(match[1]);
  }
  if (item.bonus.includes('HP')) {
    const match = item.bonus.match(/\+(\d+)\s*HP/);
    if (match) {
      const bonus = parseInt(match[1]);
      player.maxHp += bonus;
      player.hp += bonus;
    }
  }
  if (item.bonus.includes('–º–∞–≥–∏—è')) {
    const match = item.bonus.match(/\+(\d+)\s*–º–∞–≥–∏—è/);
    if (match) player.damage += parseInt(match[1]) * 0.8;
  }
  if (item.bonus.includes('–±—Ä–æ–Ω—è')) {
    const match = item.bonus.match(/\+(\d+)\s*–±—Ä–æ–Ω—è/);
    if (match) player.armor += parseInt(match[1]);
  }
}

function toggleShop() {
  const shop = document.getElementById('shopPanel');
  shop.style.display = shop.style.display === 'none' ? 'block' : 'none';
}

function checkLevelUp() {
  if (player.level >= 20) return;
  
  const nextLevel = CONFIG.EXP_TO_LEVEL[player.level];
  if (player.exp >= nextLevel) {
    player.level++;
    player.exp -= nextLevel;
    
    // Stat gains per level
    player.maxHp += 45;
    player.hp = player.maxHp;
    player.maxMp += 35;
    player.mp = player.maxMp;
    player.damage += 3;
    player.armor += 0.5;
    
    showNotification(`‚¨ÜÔ∏è –£–†–û–í–ï–ù–¨ ${player.level}!`);
    createEffect(player.x, player.y, '#ffd700', 'levelup');
    
    // Check for talent unlocks
    if ([10, 15, 20, 25].includes(player.level)) {
      showTalentChoice(player.level);
    }
  }
}

function showTalentChoice(level) {
  const popup = document.getElementById('talentPopup');
  const options = document.getElementById('talentOptions');
  options.innerHTML = '';
  
  const talents = getTalentsForLevel(level);
  
  talents.forEach((talent, idx) => {
    const option = document.createElement('div');
    option.className = 'talent-option';
    option.innerHTML = `
      <div style="font-size:20px;margin-bottom:10px;">${talent.icon}</div>
      <div style="color:#ffd700;font-weight:bold;margin-bottom:8px;">${talent.name}</div>
      <div style="color:#aaa;font-size:12px;">${talent.desc}</div>
    `;
    option.onclick = () => selectTalent(level, idx, talent);
    options.appendChild(option);
  });
  
  popup.style.display = 'flex';
}

function getTalentsForLevel(level) {
  const hero = HEROES[player.heroKey];
  
  if (level === 10) {
    return [
      { name: '+200 HP', desc: '–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ', icon: '‚ù§Ô∏è', effect: () => { player.maxHp += 200; player.hp += 200; } },
      { name: '+15% —É—Ä–æ–Ω–∞', desc: '–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –≤–µ—Å—å —É—Ä–æ–Ω', icon: '‚öîÔ∏è', effect: () => { player.damage *= 1.15; } }
    ];
  } else if (level === 15) {
    return [
      { name: '-2—Å–µ–∫ –ö–î Q', desc: '–£–º–µ–Ω—å—à–∞–µ—Ç –≤—Ä–µ–º—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è Q', icon: 'üîÑ', effect: () => { hero.abilities.q.cd -= 2000; } },
      { name: '+100 –º–∞–Ω—ã', desc: '–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –º–∞–∫—Å. –º–∞–Ω—É', icon: 'üíô', effect: () => { player.maxMp += 100; player.mp += 100; } }
    ];
  } else if (level === 20) {
    return [
      { name: '+25% –ê–æ–ï', desc: '–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Ä–∞–¥–∏—É—Å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π', icon: 'üí•', effect: () => { /* Applied in abilities */ } },
      { name: '+3 –±—Ä–æ–Ω—è', desc: '–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Ñ–∏–∑. –∑–∞—â–∏—Ç—É', icon: 'üõ°Ô∏è', effect: () => { player.armor += 3; } }
    ];
  } else if (level === 25) {
    return [
      { name: '–ë–µ—Å—Å–º–µ—Ä—Ç–∏–µ', desc: '–ü–µ—Ä–µ—Ä–æ–∂–¥–µ–Ω–∏–µ 1 —Ä–∞–∑ –∑–∞ –±–æ–π', icon: '‚ú®', effect: () => { player.hasRevive = true; } },
      { name: '+50% –∫—Ä–∏—Ç', desc: '–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —É—Ä–æ–Ω x2', icon: 'üí¢', effect: () => { player.critChance = 0.5; } }
    ];
  }
  
  return [];
}

function selectTalent(level, idx, talent) {
  player.talents[`t${level}`] = idx;
  talent.effect();
  document.getElementById('talentPopup').style.display = 'none';
  showNotification(`–í—ã–±—Ä–∞–Ω —Ç–∞–ª–∞–Ω—Ç: ${talent.name}`);
}

// Game loop
let lastTime = 0;
let deltaTime = 0;

function gameLoop(timestamp) {
  if (gameState !== 'playing') return;
  
  deltaTime = timestamp - lastTime;
  lastTime = timestamp;

  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Spawn creeps periodically
  if (timestamp - lastCreepSpawn > CONFIG.CREEP_SPAWN) {
    spawnCreeps();
    lastCreepSpawn = timestamp;
  }

  // Check Night of Warlock
  if (isNightOfWarlock && timestamp >= nightEndTime) {
    isNightOfWarlock = false;
    showNotification('–ù–æ—á—å –í–∞—Ä–ª–æ–∫–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å');
  }

  // Update player
  if (player && player.alive) {
    updatePlayer();
    checkLevelUp();
  }

  // Update camera
  updateCamera();

  // Draw everything
  drawMap();
  drawParticles();
  drawStructures(timestamp);
  drawCreeps(timestamp);
  drawNeutralMonsters(timestamp);
  drawProjectiles();
  drawEffects();
  if (player && player.alive) drawPlayer();

  // Update UI
  updateUI(timestamp);
  updateCurseBar();

  gameTime = timestamp;
  requestAnimationFrame(gameLoop);
}

function updatePlayer() {
  let dx = joystickX;
  let dy = joystickY;
  
  if (keys['w'] || keys['arrowup']) dy = -1;
  if (keys['s'] || keys['arrowdown']) dy = 1;
  if (keys['a'] || keys['arrowleft']) dx = -1;
  if (keys['d'] || keys['arrowright']) dx = 1;

  if (dx || dy) {
    const mag = Math.sqrt(dx * dx + dy * dy);
    player.vx = (dx / mag) * player.speed;
    player.vy = (dy / mag) * player.speed;
    player.staffAngle = Math.atan2(dy, dx);
  } else {
    player.vx = 0;
    player.vy = 0;
  }

  player.x += player.vx;
  player.y += player.vy;
  player.x = Math.max(player.radius, Math.min(CONFIG.MAP_SIZE - player.radius, player.x));
  player.y = Math.max(player.radius, Math.min(CONFIG.MAP_SIZE - player.radius, player.y));

  // Mana regen
  if (player.mp < player.maxMp) {
    player.mp = Math.min(player.maxMp, player.mp + 1.2);
  }
  
  // HP regen (slow)
  if (player.hp < player.maxHp) {
    player.hp = Math.min(player.maxHp, player.hp + 0.3);
  }
}

function updateCamera() {
  if (player) {
    camera.x = player.x - canvas.width / 2;
    camera.y = player.y - canvas.height / 2;
    camera.x = Math.max(0, Math.min(CONFIG.MAP_SIZE - canvas.width, camera.x));
    camera.y = Math.max(0, Math.min(CONFIG.MAP_SIZE - canvas.height, camera.y));
  }
}

function drawMap() {
  // Dark base
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw lanes (pixel style)
  ctx.strokeStyle = isNightOfWarlock ? 'rgba(60,30,80,0.6)' : 'rgba(42,42,62,0.5)';
  ctx.lineWidth = 80;
  ctx.lineCap = 'round';
  
  // Top lane
  ctx.beginPath();
  ctx.moveTo(600 - camera.x, 5000 - camera.y);
  ctx.lineTo(5000 - camera.x, 600 - camera.y);
  ctx.stroke();
  
  // Mid lane
  ctx.beginPath();
  ctx.moveTo(600 - camera.x, 600 - camera.y);
  ctx.lineTo(5400 - camera.x, 5400 - camera.y);
  ctx.stroke();
  
  // Bot lane
  ctx.beginPath();
  ctx.moveTo(5000 - camera.x, 600 - camera.y);
  ctx.lineTo(600 - camera.x, 5000 - camera.y);
  ctx.stroke();
  
  // River
  ctx.strokeStyle = 'rgba(30,60,100,0.4)';
  ctx.lineWidth = 150;
  ctx.beginPath();
  ctx.moveTo(3000 - camera.x, 0 - camera.y);
  ctx.lineTo(3000 - camera.x, CONFIG.MAP_SIZE - camera.y);
  ctx.stroke();
}

function drawParticles() {
  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    
    if (p.x < 0 || p.x > CONFIG.MAP_SIZE) p.vx *= -1;
    if (p.y < 0 || p.y > CONFIG.MAP_SIZE) p.vy *= -1;

    ctx.globalAlpha = p.alpha * (isNightOfWarlock ? 1.5 : 1);
    ctx.fillStyle = p.color;
    ctx.fillRect(
      Math.floor(p.x - camera.x), 
      Math.floor(p.y - camera.y), 
      CONFIG.PIXEL_SIZE, 
      CONFIG.PIXEL_SIZE
    );
  });
  ctx.globalAlpha = 1;
}

function drawPlayer() {
  const x = Math.floor(player.x - camera.x);
  const y = Math.floor(player.y - camera.y);

  // Draw staff
  drawStaff(x, y);

  // Draw player body (pixel art circle)
  drawPixelCircle(x, y, player.radius, player.color, true);
  
  // Draw outline
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  drawPixelCircle(x, y, player.radius, '#fff', false);

  // Health bar
  drawHealthBar(player, x, y - player.radius - 10);
}

function drawPixelCircle(cx, cy, radius, color, fill) {
  const pixelSize = CONFIG.PIXEL_SIZE;
  
  if (fill) {
    ctx.fillStyle = color;
    ctx.shadowBlur = 15;
    ctx.shadowColor = color;
  } else {
    ctx.strokeStyle = color;
  }
  
  // Simple pixel circle approximation
  for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
    const x = cx + Math.cos(angle) * radius;
    const y = cy + Math.sin(angle) * radius;
    
    if (fill) {
      ctx.fillRect(Math.floor(x), Math.floor(y), pixelSize * 2, pixelSize * 2);
    }
  }
  
  if (fill) {
    ctx.fillRect(Math.floor(cx - radius/2), Math.floor(cy - radius/2), radius, radius);
  }
  
  ctx.shadowBlur = 0;
}

function drawStaff(x, y) {
  const hero = HEROES[player.heroKey];
  const angle = player.staffAngle || 0;
  const length = 50;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  // Staff handle (wooden)
  ctx.fillStyle = '#5c3d2e';
  ctx.fillRect(-3, 5, 6, length);
  
  // Decorative bands
  ctx.fillStyle = '#8b7355';
  ctx.fillRect(-4, 15, 8, 2);
  ctx.fillRect(-4, 30, 8, 2);
  ctx.fillRect(-4, 45, 8, 2);

  // Top gem/ornament
  ctx.save();
  ctx.translate(0, -10);
  
  ctx.shadowBlur = 20;
  ctx.shadowColor = hero.gemColor;
  
  // Draw gem based on hero
  ctx.fillStyle = hero.gemColor;
  
  if (hero.emoji === 'üçç') {
    // Pineapple top
    ctx.fillRect(-8, -8, 16, 12);
    ctx.fillStyle = '#228B22';
    ctx.fillRect(-6, -12, 12, 6);
  } else if (hero.emoji === 'üåô') {
    // Moon crescent
    ctx.beginPath();
    ctx.arc(-6, 0, 10, -Math.PI/2, Math.PI/2);
    ctx.arc(6, 0, 10, Math.PI/2, -Math.PI/2);
    ctx.fill();
  } else if (hero.emoji === '‚ò†Ô∏è') {
    // Skull/potion
    ctx.fillRect(-8, -6, 16, 12);
    ctx.fillStyle = '#00FF00';
    ctx.fillRect(-6, -10, 12, 6);
  } else if (hero.emoji === 'üåø') {
    // Leaf crystal
    ctx.beginPath();
    ctx.moveTo(0, -12);
    ctx.lineTo(8, 0);
    ctx.lineTo(0, 8);
    ctx.lineTo(-8, 0);
    ctx.fill();
  } else if (hero.emoji === 'ü¶Ö') {
    // Feather/wing
    ctx.fillRect(-10, -8, 20, 4);
    ctx.fillRect(-8, -12, 16, 4);
    ctx.fillRect(-6, -16, 12, 4);
  } else if (hero.emoji === 'üî•') {
    // Flame
    ctx.beginPath();
    ctx.moveTo(0, -14);
    ctx.lineTo(6, -4);
    ctx.lineTo(2, 0);
    ctx.lineTo(-2, 0);
    ctx.lineTo(-6, -4);
    ctx.fill();
  }
  
  ctx.shadowBlur = 0;
  ctx.restore();

  // Hero icon on staff
  ctx.font = 'bold 18px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(hero.emoji, 0, -10);

  ctx.restore();
}

function drawStructures(timestamp) {
  structures.forEach(s => {
    if (!s.alive) return;
    
    const x = Math.floor(s.x - camera.x);
    const y = Math.floor(s.y - camera.y);

    // Tower/Ancient body
    ctx.fillStyle = s.team === 'radiant' ? '#4a9d4a' : '#cc4444';
    ctx.shadowBlur = 12;
    ctx.shadowColor = s.team === 'radiant' ? '#90ee90' : '#ff6666';
    
    if (s.type === 'ancient') {
      // Draw ancient as large castle
      ctx.fillRect(x - s.radius, y - s.radius, s.radius * 2, s.radius * 2);
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(x - s.radius/2, y - s.radius - 10, s.radius, 10);
    } else {
      // Draw tower as obelisk
      ctx.beginPath();
      ctx.moveTo(x, y - s.radius);
      ctx.lineTo(x + s.radius * 0.6, y + s.radius * 0.4);
      ctx.lineTo(x, y + s.radius);
      ctx.lineTo(x - s.radius * 0.6, y + s.radius * 0.4);
      ctx.closePath();
      ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 2;
    ctx.stroke();

    drawHealthBar(s, x, y - s.radius - 15);
    
    // Tower AI - attack nearby enemies
    if (timestamp - s.lastAttack > s.attackSpeed) {
      const enemies = [...creeps.filter(c => c.alive && c.team !== s.team), player].filter(e => e && e.alive);
      const target = enemies.find(e => dist(s, e) < s.range);
      
      if (target) {
        s.lastAttack = timestamp;
        const damage = s.damage * (1 - target.armor / (target.armor + 100));
        dealDamage(target, damage, target.x - camera.x, target.y - camera.y);
        
        // Visual attack line
        ctx.strokeStyle = s.team === 'radiant' ? '#90ee90' : '#ff6666';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(target.x - camera.x, target.y - camera.y);
        ctx.stroke();
      }
    }
  });
}

function drawCreeps(timestamp) {
  creeps = creeps.filter(c => {
    if (!c.alive && timestamp - (c.deathTime || 0) > 5000) return false;
    if (!c.alive) return true;

    // Creep AI
    if (!c.target || !c.target.alive || dist(c, c.target) > 1000) {
      const enemies = [
        ...structures.filter(s => s.alive && s.team !== c.team),
        ...creeps.filter(cr => cr.alive && cr.team !== c.team),
        player
      ].filter(e => e && e.alive);
      
      c.target = findNearest(c, enemies);
    }

    if (c.target) {
      const d = dist(c, c.target);
      const attackRange = c.type === 'ranged' ? c.attackRange : 80;
      
      if (d > attackRange) {
        const angle = Math.atan2(c.target.y - c.y, c.target.x - c.x);
        c.x += Math.cos(angle) * c.speed;
        c.y += Math.sin(angle) * c.speed;
      } else if (timestamp - c.lastAttack > c.attackSpeed) {
        c.lastAttack = timestamp;
        const damage = c.damage;
        dealDamage(c.target, damage, c.target.x - camera.x, c.target.y - camera.y);
      }
    }

    const x = Math.floor(c.x - camera.x);
    const y = Math.floor(c.y - camera.y);

    ctx.fillStyle = c.team === 'radiant' ? '#90ee90' : '#ff6666';
    ctx.shadowBlur = 8;
    ctx.shadowColor = ctx.fillStyle;
    
    if (c.type === 'ranged') {
      ctx.fillRect(x - c.radius, y - c.radius, c.radius * 2, c.radius * 2);
    } else {
      drawPixelCircle(x, y, c.radius, ctx.fillStyle, true);
    }
    
    ctx.shadowBlur = 0;
    drawHealthBar(c, x, y - c.radius - 8);
    
    return true;
  });
}

function drawNeutralMonsters(timestamp) {
  neutralMonsters = neutralMonsters.filter(m => {
    if (!m.alive && timestamp - (m.deathTime || 0) > 60000) {
      // Respawn after 60 seconds
      m.alive = true;
      m.hp = m.maxHp;
      m.x = m.homeX;
      m.y = m.homeY;
      m.target = null;
      m.aggressive = false;
    }
    
    if (!m.alive) return true;

    // Neutral AI - only aggressive if attacked or if Night of Warlock
    if (isNightOfWarlock && !m.aggressive) {
      m.aggressive = true;
    }
    
    if (m.aggressive) {
      if (!m.target || !m.target.alive || dist(m, m.target) > m.leashRange) {
        const enemies = [player, ...creeps].filter(e => e && e.alive && dist(m, e) < m.leashRange);
        m.target = findNearest(m, enemies);
      }
      
      if (m.target && dist(m, m.target) > 100) {
        const angle = Math.atan2(m.target.y - m.y, m.target.x - m.x);
        m.x += Math.cos(angle) * m.speed;
        m.y += Math.sin(angle) * m.speed;
        
        // Check leash - return home if too far
        if (dist(m, { x: m.homeX, y: m.homeY }) > m.leashRange) {
          m.target = null;
          m.aggressive = false;
          const angleHome = Math.atan2(m.homeY - m.y, m.homeX - m.x);
          m.x += Math.cos(angleHome) * m.speed;
          m.y += Math.sin(angleHome) * m.speed;
        }
      } else if (m.target && timestamp - m.lastAttack > m.attackSpeed) {
        m.lastAttack = timestamp;
        dealDamage(m.target, m.damage, m.target.x - camera.x, m.target.y - camera.y);
      }
    }

    const x = Math.floor(m.x - camera.x);
    const y = Math.floor(m.y - camera.y);

    const colors = { small: '#888888', medium: '#aa6600', boss: '#8844ff' };
    ctx.fillStyle = colors[m.type];
    ctx.shadowBlur = m.type === 'boss' ? 20 : 10;
    ctx.shadowColor = ctx.fillStyle;
    
    drawPixelCircle(x, y, m.radius, ctx.fillStyle, true);
    
    ctx.shadowBlur = 0;
    
    if (m.type === 'boss') {
      ctx.fillStyle = '#ff00ff';
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('üëπ', x, y);
    }
    
    drawHealthBar(m, x, y - m.radius - 12);
    
    return true;
  });
}

function drawProjectiles() {
  projectiles = projectiles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.dist += Math.sqrt(p.vx * p.vx + p.vy * p.vy);

    if (p.dist > p.maxDist) return false;

    // Hit detection
    let hit = false;
    const targets = [...creeps, ...structures, ...neutralMonsters].filter(t => t.alive && t.team !== p.team);
    
    for (const t of targets) {
      if (dist(p, t) < p.radius + t.radius) {
        const finalDamage = p.damage * (p.abilityType === 'r' ? 1.5 : 1);
        dealDamage(t, finalDamage, p.x - camera.x, p.y - camera.y);
        createEffect(p.x, p.y, p.color, 'hit');
        hit = true;
        
        // Curse progress
        if (t.type === 'tower' || t.type === 'ancient') {
          curseProgress += 5;
        }
        break;
      }
    }

    if (hit) return false;

    const x = Math.floor(p.x - camera.x);
    const y = Math.floor(p.y - camera.y);

    ctx.fillStyle = p.color;
    ctx.shadowBlur = 15;
    ctx.shadowColor = p.color;
    drawPixelCircle(x, y, p.radius, p.color, true);
    ctx.shadowBlur = 0;
    
    // Trail effect
    ctx.globalAlpha = 0.5;
    drawPixelCircle(x - p.vx, y - p.vy, p.radius * 0.7, p.color, true);
    ctx.globalAlpha = 1;
    
    return true;
  });
}

function drawEffects() {
  effects = effects.filter(e => {
    e.life++;
    
    if (e.life > e.maxLife) return false;
    
    const alpha = 1 - (e.life / e.maxLife);
    const radius = e.radius * (1 + e.life / e.maxLife);
    
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = e.color;
    ctx.lineWidth = 3;
    
    if (e.type === 'cast') {
      ctx.beginPath();
      ctx.arc(e.x - camera.x, e.y - camera.y, radius, 0, Math.PI * 2);
      ctx.stroke();
    } else if (e.type === 'hit') {
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI * 2 / 6) * i;
        const x = e.x + Math.cos(angle) * radius;
        const y = e.y + Math.sin(angle) * radius;
        ctx.fillStyle = e.color;
        ctx.fillRect(x - camera.x, y - camera.y, 4, 4);
      }
    } else if (e.type === 'levelup') {
      ctx.fillStyle = '#ffd700';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('‚¨ÜÔ∏è', e.x - camera.x, e.y - camera.y - e.life * 2);
    }
    
    ctx.globalAlpha = 1;
    return true;
  });
}

function drawHealthBar(entity, x, y) {
  const w = entity.radius * 2.5;
  const h = 5;
  const pct = entity.hp / entity.maxHp;

  ctx.fillStyle = '#222';
  ctx.fillRect(x - w / 2, y, w, h);
  
  ctx.fillStyle = pct > 0.5 ? '#0f0' : pct > 0.25 ? '#ff0' : '#f00';
  ctx.fillRect(x - w / 2, y, w * pct, h);
  
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  ctx.strokeRect(x - w / 2, y, w, h);
}

function dealDamage(target, damage, screenX, screenY) {
  target.hp -= damage;
  
  // Floating damage number
  const dmg = document.createElement('div');
  dmg.className = 'damage-text';
  dmg.textContent = `-${Math.round(damage)}`;
  dmg.style.left = (screenX + canvas.offsetLeft) + 'px';
  dmg.style.top = (screenY + canvas.offsetTop) + 'px';
  document.body.appendChild(dmg);
  setTimeout(() => dmg.remove(), 1000);

  if (target.hp <= 0) {
    target.alive = false;
    target.deathTime = gameTime;
    
    // Award gold and exp to player
    if (target.gold && player && player.alive) {
      player.gold += target.gold;
      player.exp += target.exp || 0;
      
      if (target.team === 'dire') {
        radiantKills++;
        curseProgress += 2;
      } else if (target.team === 'radiant') {
        direKills++;
      }
    }
    
    // Special notifications
    if (target.type === 'tower') {
      showNotification(`${target.team === 'dire' ? 'Radiant' : 'Dire'} –±–∞—à–Ω—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞!`);
      curseProgress += 10;
      player.gold += 200;
    } else if (target.type === 'ancient') {
      showNotification(`üèÜ ${target.team === 'dire' ? 'RADIANT' : 'DIRE'} –ü–û–ë–ï–î–ê!`);
      gameState = 'ended';
    } else if (target.type === 'boss') {
      showNotification('üíÄ –ë–æ—Å—Å –ø–æ–±–µ–∂–¥–µ–Ω! –ö–æ–º–∞–Ω–¥–∞ –ø–æ–ª—É—á–∞–µ—Ç –±–∞—Ñ—Ñ!');
      player.gold += 500;
      player.damage *= 1.2;
    }
    
    // Check curse threshold
    if (curseProgress >= CONFIG.CURSE_THRESHOLD && !isNightOfWarlock) {
      triggerNightOfWarlock();
    }
  }
  
  // Make neutral monsters aggressive
  if (target.aggressive !== undefined && !target.aggressive) {
    target.aggressive = true;
  }
}

function triggerNightOfWarlock() {
  isNightOfWarlock = true;
  nightEndTime = gameTime + CONFIG.NIGHT_DURATION;
  curseProgress = 0;
  
  showNotification('üåô –ù–û–ß–¨ –í–ê–†–õ–û–ö–ê! –ú–æ–Ω—Å—Ç—Ä—ã –≤—ã—à–ª–∏ –Ω–∞ —Å–≤–æ–±–æ–¥—É!');
  
  // Make all neutrals aggressive
  neutralMonsters.forEach(m => {
    if (m.alive) m.aggressive = true;
  });
}

function updateUI(timestamp) {
  if (!player) return;
  
  document.getElementById('hpText').textContent = `${Math.round(player.hp)}/${player.maxHp}`;
  document.getElementById('mpText').textContent = `${Math.round(player.mp)}/${player.maxMp}`;
  document.getElementById('hpBar').style.width = (player.hp / player.maxHp * 100) + '%';
  document.getElementById('mpBar').style.width = (player.mp / player.maxMp * 100) + '%';
  document.getElementById('level').textContent = player.level;
  document.getElementById('exp').textContent = player.exp;
  document.getElementById('goldAmount').textContent = player.gold;
  document.getElementById('radiantScore').textContent = radiantKills;
  document.getElementById('direScore').textContent = direKills;
  
  const mins = Math.floor(gameTime / 60000);
  const secs = Math.floor((gameTime % 60000) / 1000);
  document.getElementById('gameTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
  
  updateAbilityUI(timestamp);
  drawMinimap();
}

function updateAbilityUI(timestamp) {
  const hero = HEROES[player.heroKey];
  
  ['q', 'w', 'r'].forEach(key => {
    const ability = abilities[key];
    const abilityData = hero.abilities[key];
    const btn = document.getElementById('ability' + key.toUpperCase());
    if (!btn) return;
    
    if (ability.cd > 0) {
      ability.cd = Math.max(0, ability.cd - deltaTime);
      btn.classList.add('cd');
      const cdSec = Math.ceil(ability.cd / 1000);
      btn.innerHTML = `<span class="cd-text">${cdSec}</span>`;
    } else {
      btn.classList.remove('cd');
      btn.textContent = key.toUpperCase();
    }
  });
}

function updateCurseBar() {
  const bar = document.getElementById('curseBar');
  const pct = (curseProgress / CONFIG.CURSE_THRESHOLD) * 100;
  bar.style.width = Math.min(100, pct) + '%';
}

function drawMinimap() {
  const mini = document.getElementById('minimap');
  const mctx = mini.getContext('2d');
  if (!mctx) return;
  
  const scale = 160 / CONFIG.MAP_SIZE;
  
  mctx.fillStyle = '#0a0e1a';
  mctx.fillRect(0, 0, 160, 160);
  
  // Structures
  structures.forEach(s => {
    if (!s.alive) return;
    mctx.fillStyle = s.team === 'radiant' ? '#4a9d4a' : '#cc4444';
    const size = s.type === 'ancient' ? 6 : 4;
    mctx.fillRect(s.x * scale - size/2, s.y * scale - size/2, size, size);
  });
  
  // Neutrals (boss only)
  neutralMonsters.forEach(m => {
    if (!m.alive || m.type !== 'boss') return;
    mctx.fillStyle = '#8844ff';
    mctx.fillRect(m.x * scale - 3, m.y * scale - 3, 6, 6);
  });
  
  // Creeps (small dots)
  creeps.forEach(c => {
    if (!c.alive) return;
    mctx.fillStyle = c.team === 'radiant' ? '#90ee90' : '#ff6666';
    mctx.fillRect(c.x * scale - 1, c.y * scale - 1, 2, 2);
  });
  
  // Player
  if (player && player.alive) {
    mctx.fillStyle = player.color;
    mctx.shadowBlur = 3;
    mctx.shadowColor = player.color;
    mctx.beginPath();
    mctx.arc(player.x * scale, player.y * scale, 4, 0, Math.PI * 2);
    mctx.fill();
    mctx.shadowBlur = 0;
  }
  
  // Border
  mctx.strokeStyle = '#4a3060';
  mctx.lineWidth = 2;
  mctx.strokeRect(0, 0, 160, 160);
}

function showNotification(text) {
  const notif = document.createElement('div');
  notif.className = 'notification';
  notif.textContent = text;
  document.body.appendChild(notif);
  setTimeout(() => notif.remove(), 3000);
}

function dist(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function findNearest(entity, targets) {
  let nearest = null;
  let minDist = Infinity;
  
  targets.forEach(t => {
    const d = dist(entity, t);
    if (d < minDist) {
      minDist = d;
      nearest = t;
    }
  });
  
  return nearest;
}

// Initialize
console.log('üéÆ Curse of the Warlock –∑–∞–≥—Ä—É–∂–µ–Ω–∞!');
console.log('üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:');
console.log(`- –ì–µ—Ä–æ–µ–≤: ${Object.keys(HEROES).length}`);
console.log(`- –ü—Ä–µ–¥–º–µ—Ç–æ–≤: ${ITEMS.length}`);
console.log(`- –†–∞–∑–º–µ—Ä –∫–∞—Ä—Ç—ã: ${CONFIG.MAP_SIZE}x${CONFIG.MAP_SIZE}`);
</script>
</body>
  </html>
